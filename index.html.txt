<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Nurture — Local Digital Journal (MVP)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;padding:18px;background:#f7f9fb;color:#111}
    .wrap{max-width:900px;margin:0 auto;background:#fff;padding:18px;border-radius:10px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
    h1{margin:0 0 12px;font-size:20px}
    label{display:block;margin:10px 0 6px;font-weight:600;font-size:13px}
    input[type="text"], textarea{width:100%;padding:10px;border:1px solid #e4e7ec;border-radius:8px;font-size:14px}
    textarea{min-height:120px;resize:vertical}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#0f62fe;color:white;border:0;padding:10px 12px;border-radius:8px;font-weight:600;cursor:pointer}
    button.ghost{background:#eef2ff;color:#0f62fe;border:1px solid #e0e8ff}
    .entry{border:1px solid #eef2f8;padding:10px;border-radius:8px;margin:8px 0}
    .small{font-size:13px;color:#556}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:10px}
    .hint{font-size:12px;color:#556;margin-top:8px}
    .topbar{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
    .actions{display:flex;gap:8px}
    input[type=file]{display:none}
    .linkbox{word-break:break-all;background:#f3f7ff;padding:10px;border-radius:8px;border:1px dashed #dbe9ff;margin-top:8px}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1>Nurture — Local Digital Journal (MVP)</h1>
      <div class="small">Local-only; export/import for transfer</div>
    </div>

    <label>Entry title</label>
    <input id="title" type="text" placeholder="Today's reflection or title" />

    <label>Entry</label>
    <textarea id="content" placeholder="Write here..."></textarea>

    <div class="row">
      <button id="saveBtn">Save Entry</button>
      <button id="newBtn" class="ghost">New / Clear</button>
      <div style="flex:1"></div>
      <button id="exportBtn" class="ghost">Export (.json)</button>
      <button id="exportEncBtn" class="ghost">Export & Encrypt</button>
      <button id="importBtn" class="ghost">Import (.json)</button>
      <label class="ghost" for="fileInput" style="padding:10px;border-radius:8px;cursor:pointer">Choose File</label>
      <input id="fileInput" type="file" accept=".json,.enc" />
    </div>

    <div class="controls">
      <input id="pass" type="text" placeholder="Optional passphrase for encryption (same for export/import)" style="min-width:240px;padding:8px;border-radius:8px;border:1px solid #eee"/>
      <button id="snapshotBtn" class="ghost">Create Shareable Snapshot (short)</button>
    </div>

    <div class="hint">Tip: Your journal data stays on your device. Use Export to backup or send to buyer. If you encrypt the export, share the passphrase separately.</div>

    <h3 style="margin-top:18px">Your entries</h3>
    <div id="entriesArea" aria-live="polite"></div>

    <div id="linkArea"></div>

    <hr style="margin-top:18px"/>

    <div class="small">
      How transfer works after payment: Export the journal → email the file or upload and send download link → buyer imports it into this app (Import). See steps below.
    </div>
  </div>

<script>
/* -------------------------
   Simple IndexedDB helper
   ------------------------- */
function openDb(dbName='journalDB', storeName='entries') {
  return new Promise((res, rej) => {
    const req = indexedDB.open(dbName, 1);
    req.onupgradeneeded = e => {
      const db = e.target.result;
      if (!db.objectStoreNames.contains(storeName)) db.createObjectStore(storeName, { keyPath: 'id' });
    };
    req.onsuccess = e => res({ db: e.target.result, storeName });
    req.onerror = e => rej(e);
  });
}

async function putEntry(entry) {
  const { db, storeName } = await openDb();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readwrite');
    tx.objectStore(storeName).put(entry);
    tx.oncomplete = () => res(true);
    tx.onerror = e => rej(e);
  });
}

async function getAllEntries() {
  const { db, storeName } = await openDb();
  return new Promise((res, rej) => {
    const tx = db.transaction(storeName, 'readonly');
    const req = tx.objectStore(storeName).getAll();
    req.onsuccess = () => res(req.result || []);
    req.onerror = e => rej(e);
  });
}

/* -------------------------
   UI actions
   ------------------------- */
const titleEl = document.getElementById('title');
const contentEl = document.getElementById('content');
const saveBtn = document.getElementById('saveBtn');
const newBtn = document.getElementById('newBtn');
const entriesArea = document.getElementById('entriesArea');
const exportBtn = document.getElementById('exportBtn');
const exportEncBtn = document.getElementById('exportEncBtn');
const importBtn = document.getElementById('importBtn');
const fileInput = document.getElementById('fileInput');
const passInput = document.getElementById('pass');
const snapshotBtn = document.getElementById('snapshotBtn');
const linkArea = document.getElementById('linkArea');

saveBtn.onclick = async () => {
  const title = titleEl.value.trim();
  const content = contentEl.value.trim();
  if (!title && !content) { alert('Please enter title or content.'); return; }
  const entry = { id: Date.now().toString(), title, content, createdAt: new Date().toISOString(), updatedAt: new Date().toISOString() };
  await putEntry(entry);
  titleEl.value = ''; contentEl.value = '';
  await refreshEntries();
};

newBtn.onclick = () => { titleEl.value=''; contentEl.value=''; };

async function refreshEntries(){
  const data = await getAllEntries();
  entriesArea.innerHTML = '';
  if (!data.length) entriesArea.innerHTML = '<div class="small">No entries yet.</div>';
  data.sort((a,b)=>b.createdAt.localeCompare(a.createdAt));
  data.forEach(e=>{
    const div = document.createElement('div');
    div.className = 'entry';
    div.innerHTML = `<div style="display:flex;justify-content:space-between;align-items:center;"><strong>${escapeHtml(e.title||'Untitled')}</strong> <span class="small">${new Date(e.createdAt).toLocaleString()}</span></div>
                     <div style="margin-top:8px">${escapeHtml(e.content||'')}</div>`;
    entriesArea.appendChild(div);
  });
}
function escapeHtml(s){ if(!s) return ''; return s.replaceAll('&','&amp;').replaceAll('<','&lt;').replaceAll('>','&gt;').replaceAll('\\n','<br/>').replaceAll('\\r',''); }

/* -------------------------
   Export / Import
   ------------------------- */
exportBtn.onclick = async () => {
  const all = await getAllEntries();
  const payload = { meta:{exportedAt:new Date().toISOString(),source:'nurture-mvp'}, data: all };
  const blob = new Blob([JSON.stringify(payload, null, 2)], { type: 'application/json' });
  downloadBlob(blob, 'nurture-journal.json');
};

exportEncBtn.onclick = async () => {
  const pass = passInput.value || '';
  if (!pass) { if (!confirm('No passphrase provided. Export will be unencrypted. Continue?')) return; }
  const all = await getAllEntries();
  const payload = { meta:{exportedAt:new Date().toISOString(),source:'nurture-mvp', encrypted: !!pass}, data: all };
  const json = JSON.stringify(payload);
  if (!pass) {
    const blob = new Blob([json], { type: 'application/json' });
    downloadBlob(blob, 'nurture-journal.json');
    return;
  }
  // encrypt using Web Crypto
  const enc = new TextEncoder().encode(json);
  const encrypted = await encryptData(enc.buffer, pass);
  downloadBlob(new Blob([encrypted]), 'nurture-journal.enc');
};

function downloadBlob(blob, filename){
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

/* Import */
fileInput.onchange = async (ev) => {
  const f = ev.target.files[0];
  if (!f) return;
  try {
    if (f.name.endsWith('.enc')) {
      const pass = passInput.value;
      if (!pass) { alert('This file is encrypted. Enter passphrase in the pass field before importing.'); return; }
      const ab = await f.arrayBuffer();
      const dec = await decryptData(ab, pass);
      const json = new TextDecoder().decode(dec);
      const parsed = JSON.parse(json);
      await importPayload(parsed);
    } else {
      const text = await f.text();
      const parsed = JSON.parse(text);
      await importPayload(parsed);
    }
    alert('Import complete. Entries added to local journal.');
    await refreshEntries();
  } catch (err) {
    console.error(err);
    alert('Import failed. File may be invalid or wrong passphrase.');
  } finally {
    fileInput.value = '';
  }
};

async function importPayload(parsed) {
  if (!parsed || !Array.isArray(parsed.data)) throw new Error('Invalid file format');
  // merge by inserting each entry (keeps existing data)
  for (const e of parsed.data) {
    // ensure unique id
    const entry = { ...e };
    if (!entry.id) entry.id = Date.now().toString() + Math.floor(Math.random()*1000);
    await putEntry(entry);
  }
}

/* -------------------------
   Snapshot (short share link)
   ------------------------- */
snapshotBtn.onclick = async () => {
  const all = await getAllEntries();
  const small = JSON.stringify({ data: all.slice(0,30) }); // take recent 30 for snapshot
  if (small.length > 1500) {
    // still can create, but URLs have limits; warn
    if (!confirm('Snapshot is large and may not fit in a URL. Consider using Export instead. Continue?')) return;
  }
  const b64 = btoa(unescape(encodeURIComponent(small)));
  const url = `${location.origin}${location.pathname}?snapshot=${encodeURIComponent(b64)}`;
  linkArea.innerHTML = `<div class="linkbox"><strong>Shareable snapshot URL</strong><div style="margin-top:8px">${url}</div><div class="small" style="margin-top:6px">Open this URL in the Nurture journal app to import snapshot.</div></div>`;
};

/* On load: check snapshot param */
(async function loadOnStart(){
  await refreshEntries();
  const params = new URLSearchParams(location.search);
  const s = params.get('snapshot');
  if (s) {
    try {
      const json = decodeURIComponent(escape(atob(s)));
      const parsed = JSON.parse(json);
      if (confirm('Snapshot detected in URL. Import it to your local journal now?')) {
        await importPayload(parsed);
        await refreshEntries();
        alert('Snapshot imported.');
        // remove snapshot param from URL to avoid re-import on refresh
        history.replaceState(null,'',location.pathname);
      }
    } catch(e){ console.warn('Invalid snapshot param', e); }
  }
})();

/* -------------------------
   Encryption helpers (Web Crypto)
   ------------------------- */
async function deriveKey(passphrase, salt) {
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey('raw', enc.encode(passphrase), 'PBKDF2', false, ['deriveKey']);
  return crypto.subtle.deriveKey({
    name: 'PBKDF2',
    salt,
    iterations: 120000,
    hash: 'SHA-256'
  }, baseKey, { name: 'AES-GCM', length: 256 }, false, ['encrypt','decrypt']);
}

async function encryptData(arrayBuffer, passphrase) {
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const key = await deriveKey(passphrase, salt);
  const ct = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, key, arrayBuffer);
  // pack salt + iv + ciphertext
  const combined = new Uint8Array(salt.byteLength + iv.byteLength + ct.byteLength);
  combined.set(salt, 0);
  combined.set(iv, salt.byteLength);
  combined.set(new Uint8Array(ct), salt.byteLength + iv.byteLength);
  return combined.buffer;
}

async function decryptData(arrayBuffer, passphrase) {
  const u = new Uint8Array(arrayBuffer);
  const salt = u.slice(0, 16);
  const iv = u.slice(16, 28);
  const ct = u.slice(28);
  const key = await deriveKey(passphrase, salt);
  const dec = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, key, ct);
  return dec;
}

/* Utility for manually triggering import if user clicks import button */
importBtn.onclick = () => {
  fileInput.click();
};

</script>
</body>
</html>
